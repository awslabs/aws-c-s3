#!/usr/bin/env python3
from argparse import ArgumentParser
import json
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from sys import stderr
from time import perf_counter

ARG_PARSER = ArgumentParser(description="Plot HTTP activity")
ARG_PARSER.add_argument('--json-in', required=True,
                        help="JSON file generated by logscrape.py")
ARG_PARSER.add_argument('--img-out', required=True,
                        help="SVG file to write")


def log(msg: str):
    print(msg, file=stderr)


class PerfTimer:
    def __init__(self, name):
        self.name = name

    def __enter__(self):
        self.start = perf_counter()

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is None:
            end = perf_counter()
            log(f"{self.name}: {end - self.start:.3f} sec")


args = ARG_PARSER.parse_args()
img_fmt = args.img_out.split('.')[1]

# Open JSON file
with PerfTimer('read json'):
    with open(args.json_in, 'r') as json_file:
        S3_RUN = json.load(json_file)


def plot_streams(ax, streams: list, color, y_pos: float, bar_height: float):
    linewidth = 1.0

    # Draw horizontal bar representing lifetime of stream
    ax.plot([[i['start_time'] for i in streams], [i['end_time'] for i in streams]],
            [y_pos, y_pos],
            color=color,
            linewidth=linewidth)

    # Draw vertical bar at end of stream, so it's clear where it ends
    ax.plot([[i['end_time'] for i in streams], [i['end_time'] for i in streams]],
            [y_pos - 0.5 * bar_height, y_pos + 0.5 * bar_height],
            color=color,
            linewidth=linewidth)


with PerfTimer('plot'):
    # Create a new figure
    fig, ax = plt.subplots()

    TITLE_FONTSIZE = 40
    ax.set_title('HTTP Activity per Thread', fontsize=TITLE_FONTSIZE)
    ax.set_xlabel('Time (s)', fontsize=TITLE_FONTSIZE)
    ax.set_ylabel('EventLoop Threads', fontsize=TITLE_FONTSIZE)

    THREADS = [thread for thread in S3_RUN['threads'].values()]
    max_end_time = S3_RUN['max_time']

    # Draw vertical lines at each integer position
    for x in range(int(max_end_time) + 1):
        ax.axvline(x=x, color='whitesmoke', zorder=0)

    max_simultaneous_connections = max(
        conn['visual_idx'] for thread in THREADS for conn in thread['connections']) + 1

    HEIGHT_PER_CONN = 1.0 / max_simultaneous_connections

    # create horizontal bar chart, where each EventLoopThread is a bar from 0 -> max_end_time
    thread_bars = ax.barh(
        y=[f"Thread {i + 1}" for i in range(len(THREADS))],
        width=max_end_time,
        height=1.0,
        edgecolor='black',
        facecolor='none',
    )

    for thread_idx, thread in enumerate(THREADS):

        thread_bar = thread_bars[thread_idx]

        conn_bottom_y = thread_bar.get_y()

        for conn_idx, conn in enumerate(thread['connections']):
            conn_drawn_height = HEIGHT_PER_CONN * 0.7
            stream_drawn_height = HEIGHT_PER_CONN * 0.6
            conn_middle_y = conn_bottom_y + \
                (HEIGHT_PER_CONN * conn['visual_idx']
                 ) + (HEIGHT_PER_CONN * 0.5)

            # draw HttpConnection as box
            ax.add_patch(patches.Rectangle(
                xy=(conn['start_time'], conn_middle_y -
                    0.5 * conn_drawn_height),
                width=conn['end_time'] - conn['start_time'],
                height=conn_drawn_height,
                # edgecolor='lightgray',
                facecolor='lightgray',
            ))

            # draw HttpStreams as lines through middle of box
            plot_streams(ax, [i for i in conn['streams'] if not i['error']],
                         'green', conn_middle_y, stream_drawn_height)
            plot_streams(ax, [i for i in conn['streams'] if i['error'] and i['error'] != '???'],
                         'red', conn_middle_y, stream_drawn_height)
            plot_streams(ax, [i for i in conn['streams'] if i['error'] and i['error'] == '???'],
                         'purple', conn_middle_y, stream_drawn_height)

    # scale horizontally so 1sec is always the same width.
    img_width_inches = max_end_time * 0.4

    # scale vertically so each HttpConnection is always the same height
    img_height_inches = ((1 / HEIGHT_PER_CONN) *
                         max_simultaneous_connections * len(THREADS)) * 0.002

    # matplotlib can't do PNG larger than this
    img_width_inches = min(img_width_inches, (2**16 - 1) / fig.dpi)
    img_height_inches = min(img_height_inches, (2**16 - 1) / fig.dpi)

    fig.set_size_inches(img_width_inches, img_height_inches)

    # there's too much padding by default, tighten it up
    ax.set_xlim(0, max_end_time)
    ax.set_ylim(-0.5, len(THREADS) - 0.5)
    plt.tight_layout()
    plt.subplots_adjust(bottom=0.01, top=0.99)

with PerfTimer('save-img'):
    plt.savefig(args.img_out, format=img_fmt)
